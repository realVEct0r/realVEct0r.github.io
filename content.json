{"pages":[],"posts":[{"title":"使用 JXA 来完成 MacOS 的自动化","text":"「懒惰是人类进步的阶梯」，随着年纪越来越大，我越来越倾向于写一些自动化的脚本来完成那些重复性较强的工作。很多工作都可以用简单的几行 shell 命令来做到，比如日常的数据备份，一些数据报表的生成等。但到我现在严重依赖苹果🍎生态，「日历」、「备忘录」、「记事本」等原生应用成为我使用最频繁的 APP 之后，我遇到了新的问题。 由于服务的封闭性，服务器并没有开放开发接口之类的东西，允许开发者去控制数据，我很难去写一些程序来控制这些软件了。 Apple Script在简单搜集了一些信息资料之后，我发现了「Apple Script」这个东西。 在更深入的了解这个玩意之后，发现了更大的惊喜：绝大多数应用都有接口来供系统调用，而我们也可以使用这些接口。在「Script Editor.app」中点击菜单栏中的「File -&gt; Open Dictionary」，然后选中一个应用，就可以打开该应用的接口文档： 诶！真香！ 但在我兴致勃勃的学习这么叫做「Apple Script」的语言的时候，激情很快就被消磨的烟消云散：完全没有任何自动补全，语法高亮甚至得成功编译之后才能有，网上的学习资料也少的令人发指；简直就是被历史遗忘的脚本语言。 淦，真臭😤 但这个时候注意到在这个编辑器里我们可以切换语言，除了 Apple Script 甚至还有 JavaScript 可选！这对将 JavaScript 作为刷算法题，写一些小工具的常用语言的我来说又是一个惊喜。 JavaScript for Automation「JavaScript for Automation」，也简称「JXA」，在 OS X Yosemite 的时候就被加入了。可以允许我们用 JavaScript 来控制应用和系统。甚至还提供了 REPL 环境，osascript -il JavaScript就可以进入交互式模式： 也可以写成脚本，然后在首行加上 Shebang 就行： 然后上手成本也比鬼畜的 Apple Script 要低不少：只要你记住用下面两行命令： 12var app = Application('Reminders');app.includeStandardAdditions = true; 用这样的命令来获取一个软件，然后剩下的照着上面的接口文档调用就好了。 ！ 注意：需要在「系统设置 -&gt; 安全与隐私 -&gt; 隐私」中给你所用的终端权限，不然会发生未知错误。 举个简单的例子：比如说列出「Calendar.app」中的所有日历： 对，这悲催玩意居然不支持 Array.forEach，甚至 for ... of 也不支持 :) 有了这玩意儿之后就方便多了，我这里简单列举几个小脚本： 列举出提醒时间在三天之内的提醒事件： 1234567891011121314151617#!/usr/bin/env osascript -l JavaScriptvar app = Application('Reminders');app.includeStandardAdditions = true;var r = null;for (i = 0; i != app.reminders.length; ++i) { r = app.reminders[i]; if ( (!r.completed()) &amp;&amp; r.remindMeDate() &amp;&amp; Math.abs(new Date(r.remindMeDate()) - Date.now()) &lt; (3 * 24 * 60 * 60 * 1000) ) { console.log(`[${r.remindMeDate().toDateString()}] ${r.name()}`); }}","link":"/%E4%BD%BF%E7%94%A8-JXA-%E6%9D%A5%E5%AE%8C%E6%88%90-MacOS-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"title":"Hello world","text":"Hello! I’m VEct0r. :)","link":"/Hello-world/"},{"title":"浅谈计算机中的原码，反码与补码","text":"首先把常见的教科书上关于原码，反码与补码的概念写在这里： 原码是首位代表正负，0 代表正数 1 代表负数，其余部分按二进制顺序表示；反码中的正数与原码保持一致，负数除符号位以外其余位各自取反；补码是负数在反码的基础上 + 1。 接下来我们开始讨论。 首先说明溢出并不在我们讨论范围之内，比如 1111 1111 + 0000 0001 = 0000 0000，溢出之后一般是高位舍弃。 计算机中涉及到计算的地方都是用加法器来做的，即： 12345678A + B = ( (A OR B) AND ( NOT (A AND B) )), CARRY = (A AND B) 以上是一个半加器，只能做两个一位二进制数的相加。若要进行多位二进制数的相加要用到全加器，实现三个一位二进制数的相加（其实就是在你列竖式相加的时候要考虑进位问题）。 通过几个逻辑门，我们有了将两个二进制数字相加计算的解决方案：这是令人鼓舞的。其他的运算（减法，乘除法等等），都可以通过加法来实现。要让这台机器能够真正实现计算的功能，不仅要有计算的方法，同时还要有在机器中如何去表示数字的方法。 我们首先想到的方法一定是把这个数字转换成二进制，然后一股脑地放到内存中就好了。这不仅是一种简单符合直觉的方法，还是一种很有效的解决方法：我们之前设计的加法器可以完美使用。但这个仅仅是相加而已，如果说我们要做一个减法，对，把它看作加一个负数，那么这个负数如何表示呢？如果你写过 C 或者 C++ ，你会知道 int 是分为 signed int 和 unsigned int 两种的，他们两种的区别就在于可不可以表示负数。为了尽量不影响我们之前的储存方案（转化为二进制然后一股脑放进内存中），我们决定将最高位设计为储存负号的地方（1. 1 bit 大小就够了，仅有正负两种情况；2. 0 代表正数而 1 代表负数，这样正数的表示方法与之前的兼容的）。 负数的设计是一个很关键的问题，一方面我们希望在计算的时候可以让这个符号位也参与计算，否则要考虑将符号位与数字先分离，然后再参与计算会带来很多很多的复杂性。另一方面我们希望在做减法（即与一个负数相加的时候），也能够让符号位参与运算。 原码下面我们以 4 bit 储存一个数字为例。一般 int 大小是 8 bit，只要把讨论的范围相应扩大就可以，并不影响我们的讨论。 首先想法是加入一个符号位之后，其余部分正数和负数用一样的方式来表示。 我们来简单做一张表，列出此时十进制和相应二进制存储： DEC +0 1 2 3 4 5 6 7 BIN 0000 0001 0010 0011 0100 0101 0110 0111 BIN 1111 1110 1101 1100 1011 1010 1001 1000 DEC -7 -6 -5 -4 -3 -2 -1 -0 这张表应该按顺时针的方向读：先从左到右再从右往左。 这个就是所谓的『原码』，很容易发现这种方案有着几点不足： 涉及到负号的运算都得跪，无论是负数参与运算或者运算结果是负数，比如 3(0011) - 5(0101) = 7(0111), 5 - 3 = 5(0101) + (-3(1011)) = +0(0000)。 存在两个零值：+0(0000) 和 -0(1111)。 补码我们首先来看负数的问题。如果你试着列式去计算上边第一点举的两个例子，你会发现都存在一个减数比被减数小的问题，也就是借位（End-around Borrow）。如果把例子中的数字记作 x - y，例子中计算的结果其实是 x + 10000 - y，即 x 存在一个借位的问题。x + 10000 - y = x + (10000 - y)，所以我们把它的借位提前考虑进去，用 10000 - y 来表示 y 的负数。 这个时候十进制和相应二进制存储的对应关系是这样子的： DEC +0 1 2 3 4 5 6 7 BIN 0000 0001 0010 0011 0100 0101 0110 0111 BIN 1111 1110 1101 1100 1011 1010 1001 1000 DEC -1 -2 -3 -4 -5 -6 -7 -8 其实这个就已经是『补码』了，用 10000 - y 来表示 -y 刚好等同于除符号位以外各位取反然后再加一的操作，但 … 取反加一这样无厘头的操作没有任何原因可言。 这里补充一点：10000 是当表示一个数字所占用的大小为 4 bit 时的『借位』，如果是 8 bit 就应该是 1 0000 0000。 反码至于反码，其实就是充当『借位』的不是 1 0000，而是 1111。此时对应关系是这样： DEC +0 1 2 3 4 5 6 7 BIN 0000 0001 0010 0011 0100 0101 0110 0111 BIN 1111 1110 1101 1100 1011 1010 1001 1000 DEC -0 -1 -2 -3 -4 -5 -6 -7 其实就是将原码中负数这排反转过来。补码是在反码的基础上向左偏移一位，将 -0 “挤” 出去。 很容易发现这种方法解决了负号运算的问题，但依旧存在两个零值。","link":"/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%E4%B8%8E%E8%A1%A5%E7%A0%81/"},{"title":"VS Code 搭建 c 编译、调试环境","text":"本文演示了在 MacOS 系统，使用 VS Code，clang 编译器，以及 cmake 编译配置工具来配置开发环境。 同时，本文的配置上传到了 这里 作为模版仓库。 实现的功能： 代码高亮 自动补全 定义 / 引用跳转 一键编译 / 调试 断点 最终的项目目录树： 123456789101112131415161718192021.├── .editorconfig├── .gitignore├── .vscode│ ├── c_cpp_properties.json│ ├── launch.json│ └── tasks.json├── CMakeLists.txt├── README.md├── build├── src│ ├── CMakeLists.txt│ ├── array.c│ └── includes│ ├── array.h│ └── common.h└── test ├── CMakeLists.txt └── array_test.c5 directories, 13 files 安装扩展 C/C++: ms-vscode.cpptools CMAKE: twxs.cmake 我知道有个叫做 CMake Tools 的扩展，但…体验并不好。 配置编译工具首先请确认 clang、cmake、lldb 等已经安装，并添加到 PATH。 先来创建源代码文件夹和测试代码文件夹： 123456789101112.├── CMakeLists.txt├── build├── src│ ├── CMakeLists.txt│ ├── array.c│ └── includes│ ├── array.h│ └── common.h└── test ├── CMakeLists.txt └── array_test.c 一个 src 目录，来存放源代码文件；一个 test 目录来存放测试代码文件；以及一个 build 目录来存放编译之后的文件。然后在以上三个目录中分别创建一个 CMakeLists.txt 文件：来控制不同的代码的编译方式。 项目根目录 ./CMakeLists.txt: 1234567cmake_minimum_required(VERSION 3.15)project(vscode-c-project LANGUAGES C)set(CMAKE_C_FLAGS \"-g\")add_subdirectory(src)add_subdirectory(test) src 目录 ./src/CMakeLists.txt: 要记得给 clang 一个 -g 的 flag，来生成带有调试信息的编译文件。 123include_directories(includes)add_library(array SHARED array.c) 注明 include 头文件的位置，将 array.c 编译成共享链接库。 test 目录 ./test/CMakeLists.txt: 1234include_directories(../src/includes)add_executable(array_test array_test.c)target_link_libraries(array_test array) 同样注明 include 头文件的位置，编译可执行文件，然后链接 src 目录下生成的链接库。 配置编译器执行 C/C++: Edit Configurations，生成 .vscode/c_cpp_properties.json 文件。这里定义了编译器的路径，还有搜索一些库文件的路径，以及编译的版本。因为头文件的位置并不和源文件在同一目录下，所以这里应该指明一下包含头文件的位置： 123456789101112131415{ \"configurations\": [ { \"name\": \"Mac\", \"includePath\": [\"${workspaceFolder}/src/includes\"], \"defines\": [], \"macFrameworkPath\": [\"/System/Library/Frameworks\", \"/Library/Frameworks\"], \"compilerPath\": \"/usr/bin/clang\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x64\" } ], \"version\": 4} 配置任务执行 Tasks: Configure Task，生成 .vscode/tasks.json 文件，然后配置两个任务: 1234567891011121314151617181920{ \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"clean\", \"type\": \"shell\", \"command\": \"rm -rf build &amp;&amp; mkdir build\" }, { \"label\": \"build\", \"type\": \"shell\", \"command\": \"cd build &amp;&amp; cmake .. &amp;&amp; make\", \"dependsOn\": \"clean\", \"group\": { \"kind\": \"build\", \"isDefault\": true } } ]} 一个 clean 任务用来清理编译之后的文件；一个 build 任务用来把代码都编译到 build 文件下。 同时将 build 任务设为了默认的编译任务，按 shift + command + b 可以直接一键编译。 到这里就完成编译的配置了，能成功编译之后再进行下一步。 配置调试直接点击调试栏的齿轮，选择 C++ (GDB/LLDB)，会自动生成 .vscode/launch.json 文件。简单修改一下 program 和 preLaunchTask 字段： 123456789101112131415161718{ \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"clang build and debug active file\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/build/${relativeFileDirname}/${fileBasenameNoExtension}\", \"args\": [], \"stopAtEntry\": true, \"cwd\": \"${workspaceFolder}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"lldb\", \"preLaunchTask\": \"build\" } ]} 在每次调试前自动执行编译任务，并且调试 build 目录下编译之后的程序。 代码规范如果有必要的话可以在添加 .editconfig 来控制代码风格，.gitignore 来在 git 检测代码更改时忽略编译之后的文件，README.md 来说明项目内容。 最终的效果图： 直接按 F5 就会编译并调试当前打开的文件哦~","link":"/%E4%BD%BF%E7%94%A8-VS-Code-%E6%90%AD%E5%BB%BA-C-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"MacOS","slug":"MacOS","link":"/tags/MacOS/"},{"name":"Getting Started","slug":"Getting-Started","link":"/tags/Getting-Started/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"}],"categories":[{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"CS","slug":"CS","link":"/categories/CS/"}]}