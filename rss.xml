<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>VEct0r&#39;s Blog</title>
    <link>http://blog.vect0r.me/</link>
    
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>VEct0r&#39;s Blog</description>
    <pubDate>Sat, 06 Jun 2020 13:10:52 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>使用 JXA 来完成 MacOS 的自动化</title>
      <link>http://blog.vect0r.me/%E4%BD%BF%E7%94%A8-JXA-%E6%9D%A5%E5%AE%8C%E6%88%90-MacOS-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96/</link>
      <guid>http://blog.vect0r.me/%E4%BD%BF%E7%94%A8-JXA-%E6%9D%A5%E5%AE%8C%E6%88%90-MacOS-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96/</guid>
      <pubDate>Sat, 06 Jun 2020 10:25:45 GMT</pubDate>
      <description>
      
        &lt;p&gt;「懒惰是人类进步的阶梯」，随着年纪越来越大，我越来越倾向于写一些自动化的脚本来完成那些重复性较强的工作。很多工作都可以用简单的几行 shell 命令来做到，比如日常的数据备份，一些数据报表的生成等。但到我现在严重依赖苹果🍎生态，「日历」、「备忘录」、「记事本」等原生应用成为我使用最频繁的 APP 之后，我遇到了新的问题。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>「懒惰是人类进步的阶梯」，随着年纪越来越大，我越来越倾向于写一些自动化的脚本来完成那些重复性较强的工作。很多工作都可以用简单的几行 shell 命令来做到，比如日常的数据备份，一些数据报表的生成等。但到我现在严重依赖苹果🍎生态，「日历」、「备忘录」、「记事本」等原生应用成为我使用最频繁的 APP 之后，我遇到了新的问题。</p><a id="more"></a><p>由于服务的封闭性，服务器并没有开放开发接口之类的东西，允许开发者去控制数据，我很难去写一些程序来控制这些软件了。</p><h2 id="Apple-Script"><a href="#Apple-Script" class="headerlink" title="Apple Script"></a>Apple Script</h2><p>在简单搜集了一些信息资料之后，我发现了「Apple Script」这个东西。</p><p><img src="img/2020-06-06-18-46-16.png" alt="Apple Script"></p><p>在更深入的了解这个玩意之后，发现了更大的惊喜：绝大多数应用都有接口来供系统调用，而我们也可以使用这些接口。在「Script Editor.app」中点击菜单栏中的「File -&gt; Open Dictionary」，然后选中一个应用，就可以打开该应用的接口文档：</p><p><img src="img/2020-06-06-18-49-52.png" alt="Safari 的接口文档"></p><p>诶！真香！</p><p>但在我兴致勃勃的学习这么叫做「Apple Script」的语言的时候，激情很快就被消磨的烟消云散：完全没有任何自动补全，语法高亮甚至得成功编译之后才能有，网上的学习资料也少的令人发指；简直就是被历史遗忘的脚本语言。</p><p>淦，真臭😤</p><p>但这个时候注意到在这个编辑器里我们可以切换语言，除了 Apple Script 甚至还有 JavaScript 可选！这对将 JavaScript 作为刷算法题，写一些小工具的常用语言的我来说又是一个惊喜。</p><h2 id="JavaScript-for-Automation"><a href="#JavaScript-for-Automation" class="headerlink" title="JavaScript for Automation"></a>JavaScript for Automation</h2><p>「JavaScript for Automation」，也简称「JXA」，在 OS X Yosemite 的时候就被加入了。可以允许我们用 JavaScript 来控制应用和系统。甚至还提供了 REPL 环境，<code>osascript -il JavaScript</code>就可以进入交互式模式：</p><p><img src="img/2020-06-06-19-04-19.png" alt="交互式环境"></p><p>也可以写成脚本，然后在首行加上 Shebang 就行：</p><p><img src="img/2020-06-06-19-07-49.png" alt="作为脚本直接运行"></p><p>然后上手成本也比鬼畜的 Apple Script 要低不少：只要你记住用下面两行命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = Application(<span class="string">'Reminders'</span>);</span><br><span class="line">app.includeStandardAdditions = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>用这样的命令来获取一个软件，然后剩下的照着上面的接口文档调用就好了。</p><blockquote><p>！ 注意：需要在「系统设置 -&gt; 安全与隐私 -&gt; 隐私」中给你所用的终端权限，不然会发生未知错误。</p></blockquote><p><img src="img/2020-06-06-19-19-21.png" alt="如果没有给相关权限会发成错误"></p><p><img src="img/2020-06-06-19-21-07.png" alt="在「隐私」中配置相关权限"></p><p>举个简单的例子：比如说列出「Calendar.app」中的所有日历：</p><!-- ![](img/2020-06-06-19-29-28.png) --><p><img src="img/2020-06-06-19-34-42.png" alt="列出所有的日历"></p><p>对，这悲催玩意居然不支持 <code>Array.forEach</code>，甚至 <code>for ... of</code> 也不支持 :)</p><p>有了这玩意儿之后就方便多了，我这里简单列举几个小脚本：</p><p>列举出提醒时间在三天之内的提醒事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env osascript -l JavaScript</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = Application(<span class="string">'Reminders'</span>);</span><br><span class="line">app.includeStandardAdditions = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i != app.reminders.length; ++i) &#123;</span><br><span class="line">    r = app.reminders[i];</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (!r.completed())</span><br><span class="line">        &amp;&amp; r.remindMeDate()</span><br><span class="line">        &amp;&amp; <span class="built_in">Math</span>.abs(<span class="keyword">new</span> <span class="built_in">Date</span>(r.remindMeDate()) - <span class="built_in">Date</span>.now()) &lt; (<span class="number">3</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;r.remindMeDate().toDateString()&#125;</span>] <span class="subst">$&#123;r.name()&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://blog.vect0r.me/%E4%BD%BF%E7%94%A8-JXA-%E6%9D%A5%E5%AE%8C%E6%88%90-MacOS-%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈计算机中的原码，反码与补码</title>
      <link>http://blog.vect0r.me/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%E4%B8%8E%E8%A1%A5%E7%A0%81/</link>
      <guid>http://blog.vect0r.me/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%E4%B8%8E%E8%A1%A5%E7%A0%81/</guid>
      <pubDate>Wed, 18 Mar 2020 06:13:34 GMT</pubDate>
      <description>
      
        &lt;p&gt;首先把常见的教科书上关于原码，反码与补码的概念写在这里：&lt;/p&gt;
&lt;p&gt;原码是首位代表正负，&lt;code&gt;0&lt;/code&gt; 代表正数 &lt;code&gt;1&lt;/code&gt; 代表负数，其余部分按二进制顺序表示；&lt;br&gt;反码中的正数与原码保持一致，负数除符号位以外其余位各自取反；&lt;br&gt;补码是负数在反码的基础上 + 1。&lt;/p&gt;
&lt;p&gt;接下来我们开始讨论。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>首先把常见的教科书上关于原码，反码与补码的概念写在这里：</p><p>原码是首位代表正负，<code>0</code> 代表正数 <code>1</code> 代表负数，其余部分按二进制顺序表示；<br>反码中的正数与原码保持一致，负数除符号位以外其余位各自取反；<br>补码是负数在反码的基础上 + 1。</p><p>接下来我们开始讨论。</p><a id="more"></a><p>首先说明溢出并不在我们讨论范围之内，比如 <code>1111 1111</code> + <code>0000 0001</code> = <code>0000 0000</code>，溢出之后一般是高位舍弃。</p><p>计算机中涉及到计算的地方都是用加法器来做的，即：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A + <span class="keyword">B </span>= (</span><br><span class="line">    (A <span class="keyword">OR </span><span class="keyword">B)</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">AND </span></span><br><span class="line">    (</span><br><span class="line">      NOT (A <span class="keyword">AND </span><span class="keyword">B)</span></span><br><span class="line"><span class="keyword"> </span>   )</span><br><span class="line">), </span><br><span class="line">CARRY = (A <span class="keyword">AND </span><span class="keyword">B)</span></span><br></pre></td></tr></table></figure><p>以上是一个半加器，只能做两个一位二进制数的相加。若要进行多位二进制数的相加要用到全加器，实现三个一位二进制数的相加（其实就是在你列竖式相加的时候要考虑进位问题）。</p><p>通过几个逻辑门，我们有了将两个二进制数字相加计算的解决方案：这是令人鼓舞的。其他的运算（减法，乘除法等等），都可以通过加法来实现。要让这台机器能够真正实现计算的功能，不仅要有计算的方法，同时还要有在机器中如何去表示数字的方法。</p><p>我们首先想到的方法一定是把这个数字转换成二进制，然后一股脑地放到内存中就好了。这不仅是一种简单符合直觉的方法，还是一种很有效的解决方法：我们之前设计的加法器可以完美使用。但这个仅仅是相加而已，如果说我们要做一个减法，对，把它看作加一个负数，那么这个负数如何表示呢？如果你写过 C 或者 C++ ，你会知道 int 是分为 <code>signed int</code> 和 <code>unsigned int</code> 两种的，他们两种的区别就在于可不可以表示负数。为了尽量不影响我们之前的储存方案（转化为二进制然后一股脑放进内存中），我们决定将最高位设计为储存负号的地方（1. 1 bit 大小就够了，仅有正负两种情况；2. <code>0</code> 代表正数而 <code>1</code> 代表负数，这样正数的表示方法与之前的兼容的）。</p><p>负数的设计是一个很关键的问题，一方面我们希望在计算的时候可以让这个符号位也参与计算，否则要考虑将符号位与数字先分离，然后再参与计算会带来很多很多的复杂性。另一方面我们希望在做减法（即与一个负数相加的时候），也能够让符号位参与运算。</p><h2 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h2><p>下面我们以 4 bit 储存一个数字为例。一般 int 大小是 8 bit，只要把讨论的范围相应扩大就可以，并不影响我们的讨论。</p><p>首先想法是加入一个符号位之后，其余部分正数和负数用一样的方式来表示。</p><p>我们来简单做一张表，列出此时十进制和相应二进制存储：</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><code>DEC</code></td><td align="center">+0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr><tr><td align="center"><code>BIN</code></td><td align="center">0000</td><td align="center">0001</td><td align="center">0010</td><td align="center">0011</td><td align="center">0100</td><td align="center">0101</td><td align="center">0110</td><td align="center">0111</td></tr><tr><td align="center"><code>BIN</code></td><td align="center">1111</td><td align="center">1110</td><td align="center">1101</td><td align="center">1100</td><td align="center">1011</td><td align="center">1010</td><td align="center">1001</td><td align="center">1000</td></tr><tr><td align="center"><code>DEC</code></td><td align="center">-7</td><td align="center">-6</td><td align="center">-5</td><td align="center">-4</td><td align="center">-3</td><td align="center">-2</td><td align="center">-1</td><td align="center">-0</td></tr></tbody></table><blockquote><p>这张表应该按顺时针的方向读：先从左到右再从右往左。</p></blockquote><p>这个就是所谓的『原码』，很容易发现这种方案有着几点不足：</p><ol><li>涉及到负号的运算都得跪，无论是负数参与运算或者运算结果是负数，比如 3(<code>0011</code>) - 5(<code>0101</code>) = 7(<code>0111</code>), 5 - 3 = 5(<code>0101</code>) + (-3(<code>1011</code>)) = +0(<code>0000</code>)。</li><li>存在两个零值：+0(<code>0000</code>) 和 -0(<code>1111</code>)。</li></ol><h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>我们首先来看负数的问题。如果你试着列式去计算上边第一点举的两个例子，你会发现都存在一个减数比被减数小的问题，也就是借位（<code>End-around Borrow</code>）。如果把例子中的数字记作 <code>x - y</code>，例子中计算的结果其实是 <code>x + 10000  - y</code>，即 x 存在一个借位的问题。<code>x + 10000 - y = x + (10000 - y)</code>，所以我们把它的借位提前考虑进去，用 <code>10000 - y</code> 来表示 y 的负数。</p><p>这个时候十进制和相应二进制存储的对应关系是这样子的：</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><code>DEC</code></td><td align="center">+0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr><tr><td align="center"><code>BIN</code></td><td align="center">0000</td><td align="center">0001</td><td align="center">0010</td><td align="center">0011</td><td align="center">0100</td><td align="center">0101</td><td align="center">0110</td><td align="center">0111</td></tr><tr><td align="center"><code>BIN</code></td><td align="center">1111</td><td align="center">1110</td><td align="center">1101</td><td align="center">1100</td><td align="center">1011</td><td align="center">1010</td><td align="center">1001</td><td align="center">1000</td></tr><tr><td align="center"><code>DEC</code></td><td align="center">-1</td><td align="center">-2</td><td align="center">-3</td><td align="center">-4</td><td align="center">-5</td><td align="center">-6</td><td align="center">-7</td><td align="center">-8</td></tr></tbody></table><p>其实这个就已经是『补码』了，用 <code>10000 - y</code> 来表示 <code>-y</code> 刚好等同于除符号位以外各位取反然后再加一的操作，但 … 取反加一这样无厘头的操作没有任何原因可言。</p><p>这里补充一点：<code>10000</code> 是当表示一个数字所占用的大小为 4 bit 时的『借位』，如果是 8 bit 就应该是 <code>1 0000 0000</code>。</p><h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>至于反码，其实就是充当『借位』的不是 <code>1 0000</code>，而是 <code>1111</code>。此时对应关系是这样：</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center"><code>DEC</code></td><td align="center">+0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td></tr><tr><td align="center"><code>BIN</code></td><td align="center">0000</td><td align="center">0001</td><td align="center">0010</td><td align="center">0011</td><td align="center">0100</td><td align="center">0101</td><td align="center">0110</td><td align="center">0111</td></tr><tr><td align="center"><code>BIN</code></td><td align="center">1111</td><td align="center">1110</td><td align="center">1101</td><td align="center">1100</td><td align="center">1011</td><td align="center">1010</td><td align="center">1001</td><td align="center">1000</td></tr><tr><td align="center"><code>DEC</code></td><td align="center">-0</td><td align="center">-1</td><td align="center">-2</td><td align="center">-3</td><td align="center">-4</td><td align="center">-5</td><td align="center">-6</td><td align="center">-7</td></tr></tbody></table><p>其实就是将原码中负数这排反转过来。补码是在反码的基础上向左偏移一位，将 <code>-0</code> “挤” 出去。</p><p>很容易发现这种方法解决了负号运算的问题，但依旧存在两个零值。</p>]]></content:encoded>
      
      <comments>http://blog.vect0r.me/%E6%B5%85%E8%B0%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%A0%81%EF%BC%8C%E5%8F%8D%E7%A0%81%E4%B8%8E%E8%A1%A5%E7%A0%81/#disqus_thread</comments>
    </item>
    
    <item>
      <title>VS Code 搭建 c 编译、调试环境</title>
      <link>http://blog.vect0r.me/%E4%BD%BF%E7%94%A8-VS-Code-%E6%90%AD%E5%BB%BA-C-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</link>
      <guid>http://blog.vect0r.me/%E4%BD%BF%E7%94%A8-VS-Code-%E6%90%AD%E5%BB%BA-C-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</guid>
      <pubDate>Sun, 20 Oct 2019 03:57:33 GMT</pubDate>
      <description>
      
        &lt;p&gt;本文演示了在 MacOS 系统，使用 VS Code，clang 编译器，以及 cmake 编译配置工具来配置开发环境。&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>本文演示了在 MacOS 系统，使用 VS Code，clang 编译器，以及 cmake 编译配置工具来配置开发环境。</p><a id="more"></a><p>同时，本文的配置上传到了 <a href="https://github.com/realVEct0r/vscode-c-project">这里</a> 作为模版仓库。</p><p>实现的功能：</p><ul><li><input checked="" disabled="" type="checkbox"> 代码高亮</li><li><input checked="" disabled="" type="checkbox"> 自动补全</li><li><input checked="" disabled="" type="checkbox"> 定义 / 引用跳转</li><li><input checked="" disabled="" type="checkbox"> 一键编译 / 调试</li><li><input checked="" disabled="" type="checkbox"> 断点</li></ul><p>最终的项目目录树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .editorconfig</span><br><span class="line">├── .gitignore</span><br><span class="line">├── .vscode</span><br><span class="line">│   ├── c_cpp_properties.json</span><br><span class="line">│   ├── launch.json</span><br><span class="line">│   └── tasks.json</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">├── build</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── array.c</span><br><span class="line">│   └── includes</span><br><span class="line">│       ├── array.h</span><br><span class="line">│       └── common.h</span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── array_test.c</span><br><span class="line"></span><br><span class="line">5 directories, 13 files</span><br></pre></td></tr></table></figure><h2 id="安装扩展"><a href="#安装扩展" class="headerlink" title="安装扩展"></a>安装扩展</h2><ul><li>C/C++: <code>ms-vscode.cpptools</code></li><li>CMAKE: <code>twxs.cmake</code></li></ul><p>我知道有个叫做 <code>CMake Tools</code> 的扩展，但…体验并不好。</p><h2 id="配置编译工具"><a href="#配置编译工具" class="headerlink" title="配置编译工具"></a>配置编译工具</h2><p>首先请确认 clang、cmake、lldb 等已经安装，并添加到 PATH。</p><p>先来创建源代码文件夹和测试代码文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── build</span><br><span class="line">├── src</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── array.c</span><br><span class="line">│   └── includes</span><br><span class="line">│       ├── array.h</span><br><span class="line">│       └── common.h</span><br><span class="line">└── <span class="built_in">test</span></span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── array_test.c</span><br></pre></td></tr></table></figure><p>一个 <code>src</code> 目录，来存放源代码文件；一个 <code>test</code> 目录来存放测试代码文件；以及一个 <code>build</code> 目录来存放编译之后的文件。然后在以上三个目录中分别创建一个 <code>CMakeLists.txt</code> 文件：来控制不同的代码的编译方式。</p><p>项目根目录 <code>./CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(vscode-c-<span class="keyword">project</span> LANGUAGES C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">"-g"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(<span class="keyword">test</span>)</span><br></pre></td></tr></table></figure><p>src 目录 <code>./src/CMakeLists.txt</code>:</p><p>要记得给 clang 一个 <code>-g</code> 的 flag，来生成带有调试信息的编译文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(includes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(array SHARED array.c)</span><br></pre></td></tr></table></figure><p>注明 include 头文件的位置，将 <code>array.c</code> 编译成共享链接库。</p><p>test 目录 <code>./test/CMakeLists.txt</code>:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(../src/includes)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(array_test array_test.c)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(array_test array)</span><br></pre></td></tr></table></figure><p>同样注明 include 头文件的位置，编译可执行文件，然后链接 src 目录下生成的链接库。</p><h2 id="配置编译器"><a href="#配置编译器" class="headerlink" title="配置编译器"></a>配置编译器</h2><p>执行 <code>C/C++: Edit Configurations</code>，生成 <code>.vscode/c_cpp_properties.json</code> 文件。这里定义了编译器的路径，还有搜索一些库文件的路径，以及编译的版本。因为头文件的位置并不和源文件在同一目录下，所以这里应该指明一下包含头文件的位置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Mac"</span>,</span><br><span class="line">      <span class="attr">"includePath"</span>: [<span class="string">"$&#123;workspaceFolder&#125;/src/includes"</span>],</span><br><span class="line">      <span class="attr">"defines"</span>: [],</span><br><span class="line">      <span class="attr">"macFrameworkPath"</span>: [<span class="string">"/System/Library/Frameworks"</span>, <span class="string">"/Library/Frameworks"</span>],</span><br><span class="line">      <span class="attr">"compilerPath"</span>: <span class="string">"/usr/bin/clang"</span>,</span><br><span class="line">      <span class="attr">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">      <span class="attr">"cppStandard"</span>: <span class="string">"c++17"</span>,</span><br><span class="line">      <span class="attr">"intelliSenseMode"</span>: <span class="string">"clang-x64"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置任务"><a href="#配置任务" class="headerlink" title="配置任务"></a>配置任务</h2><p>执行 <code>Tasks: Configure Task</code>，生成 <code>.vscode/tasks.json</code> 文件，然后配置两个任务:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"tasks"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"clean"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"rm -rf build &amp;&amp; mkdir build"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"label"</span>: <span class="string">"build"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">      <span class="attr">"command"</span>: <span class="string">"cd build &amp;&amp; cmake .. &amp;&amp; make"</span>,</span><br><span class="line">      <span class="attr">"dependsOn"</span>: <span class="string">"clean"</span>,</span><br><span class="line">      <span class="attr">"group"</span>: &#123;</span><br><span class="line">        <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">        <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>clean</code> 任务用来清理编译之后的文件；一个 <code>build</code> 任务用来把代码都编译到 <code>build</code> 文件下。</p><p>同时将 build 任务设为了默认的编译任务，按 <code>shift + command + b</code> 可以直接一键编译。</p><p>到这里就完成编译的配置了，能成功编译之后再进行下一步。</p><h2 id="配置调试"><a href="#配置调试" class="headerlink" title="配置调试"></a>配置调试</h2><p>直接点击调试栏的齿轮，选择 <code>C++ (GDB/LLDB)</code>，会自动生成 <code>.vscode/launch.json</code> 文件。简单修改一下 <code>program</code> 和 <code>preLaunchTask</code> 字段：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"clang build and debug active file"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/build/$&#123;relativeFileDirname&#125;/$&#123;fileBasenameNoExtension&#125;"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">      <span class="attr">"environment"</span>: [],</span><br><span class="line">      <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"lldb"</span>,</span><br><span class="line">      <span class="attr">"preLaunchTask"</span>: <span class="string">"build"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次调试前自动执行编译任务，并且调试 build 目录下编译之后的程序。</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>如果有必要的话可以在添加 <code>.editconfig</code> 来控制代码风格，<code>.gitignore</code> 来在 git 检测代码更改时忽略编译之后的文件，<code>README.md</code> 来说明项目内容。</p><p>最终的效果图：</p><p><img src="img/2019-10-20-11-50-44.png" alt=""></p><p>直接按 <code>F5</code> 就会编译并调试当前打开的文件哦~</p>]]></content:encoded>
      
      <comments>http://blog.vect0r.me/%E4%BD%BF%E7%94%A8-VS-Code-%E6%90%AD%E5%BB%BA-C-C-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Hello world</title>
      <link>http://blog.vect0r.me/Hello-world/</link>
      <guid>http://blog.vect0r.me/Hello-world/</guid>
      <pubDate>Sat, 31 Aug 2019 13:06:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;Hello! I’m &lt;code&gt;VEct0r&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;:)&lt;/p&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<p>Hello! I’m <code>VEct0r</code>.</p><p>:)</p><a id="more"></a>]]></content:encoded>
      
      <comments>http://blog.vect0r.me/Hello-world/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
